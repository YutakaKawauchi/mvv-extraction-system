import React, { useMemo, useState } from 'react';
import { useAnalysisStore } from '../../stores/analysisStore';
import { LoadingSpinner } from '../common';
import { Award, CheckCircle, AlertTriangle, XCircle, BarChart3 } from 'lucide-react';
import { TinySegmenter } from '@birchill/tiny-segmenter';

interface QualityMetrics {
  clarity: number;      // ÊòéÁ¢∫ÊÄß
  specificity: number;  // ÂÖ∑‰ΩìÊÄß
  actionability: number; // Ë°åÂãïÊåáÂêëÊÄß
  authenticity: number; // Áã¨Ëá™ÊÄß
  completeness: number; // ÂÆåÂÖ®ÊÄß
  overall: number;      // Á∑èÂêà„Çπ„Ç≥„Ç¢
}

interface CompanyAssessment {
  companyId: string;
  companyName: string;
  category: string;
  mission: QualityMetrics;
  vision: QualityMetrics;
  values: QualityMetrics;
  overall: QualityMetrics;
  recommendations: string[];
  grade: 'A' | 'B' | 'C' | 'D' | 'F';
}

export const MVVQualityAssessment: React.FC = () => {
  const { data, isLoading } = useAnalysisStore();
  const [selectedCategory, setSelectedCategory] = useState<string>('all');
  const [sortBy, setSortBy] = useState<'overall' | 'mission' | 'vision' | 'values'>('overall');

  const segmenter = useMemo(() => new TinySegmenter(), []);

  // MVV„ÉÜ„Ç≠„Çπ„Éà„ÅÆÂìÅË≥™Ë©ï‰æ°ÔºàÂÆâÂÖ®ÂåñÁâàÔºâ
  const assessMVVText = (text: string, type: 'mission' | 'vision' | 'values', segmenter: any): QualityMetrics => {
    if (!text || typeof text !== 'string' || text.trim().length === 0) {
      return { clarity: 0, specificity: 0, actionability: 0, authenticity: 0, completeness: 0, overall: 0 };
    }

    try {
      const words = segmenter.segment(text);
      if (!Array.isArray(words)) {
        console.warn('Segmenter did not return an array:', words);
        return { clarity: 0, specificity: 0, actionability: 0, authenticity: 0, completeness: 0, overall: 0 };
      }
      
      const wordCount = words.filter((w: string) => typeof w === 'string' && w.length > 1).length;

      // ÊòéÁ¢∫ÊÄßË©ï‰æ°
      const clarity = assessClarity(text, wordCount);
      
      // ÂÖ∑‰ΩìÊÄßË©ï‰æ°
      const specificity = assessSpecificity(text, words);
      
      // Ë°åÂãïÊåáÂêëÊÄßË©ï‰æ°
      const actionability = assessActionability(text, words, type);
      
      // Áã¨Ëá™ÊÄßË©ï‰æ°Ôºà‰∏ÄËà¨ÁöÑ„Åß„Å™„ÅÑË™ûÂΩô„ÅÆ‰ΩøÁî®Ôºâ
      const authenticity = assessAuthenticity(words);
      
      // ÂÆåÂÖ®ÊÄßÔºà„Åì„ÅÆ„É°„ÇΩ„ÉÉ„Éâ„Åß„ÅØÊñáÂ≠óÊï∞„Éô„Éº„ÇπÔºâ
      const completeness = Math.min(wordCount / 20, 1); // 20Ë™û‰ª•‰∏ä„ÅßÊ∫ÄÁÇπ

      const overall = (clarity + specificity + actionability + authenticity + completeness) / 5;

      // „Çπ„Ç≥„Ç¢„ÅÆÊ§úË®º„Å®Ê≠£Ë¶èÂåñ
      const normalizeScore = (score: number) => Math.max(0, Math.min(1, isFinite(score) ? score : 0));

      return {
        clarity: normalizeScore(clarity),
        specificity: normalizeScore(specificity),
        actionability: normalizeScore(actionability),
        authenticity: normalizeScore(authenticity),
        completeness: normalizeScore(completeness),
        overall: normalizeScore(overall)
      };
    } catch (error) {
      console.warn('Error in assessMVVText:', error);
      return { clarity: 0, specificity: 0, actionability: 0, authenticity: 0, completeness: 0, overall: 0 };
    }
  };

  // ÊòéÁ¢∫ÊÄßË©ï‰æ°
  const assessClarity = (text: string, _wordCount: number): number => {
    let score = 0.5; // „Éô„Éº„Çπ„Çπ„Ç≥„Ç¢
    
    // Êñá„ÅÆÈï∑„ÅïÔºàÈÅ©Â∫¶„Å™Èï∑„Åï„ÅåÊúõ„Åæ„Åó„ÅÑÔºâ
    const length = text.length;
    if (length >= 20 && length <= 100) score += 0.2;
    else if (length > 100 && length <= 200) score += 0.1;
    
    // Â∞ÇÈñÄÁî®Ë™û„ÇÑÊõñÊòß„Å™Ë°®Áèæ„ÅÆÊ∏õÁÇπ
    const vagueWords = ['„Å™„Å©', '„Åù„ÅÆ‰ªñ', 'Á≠â', '„ÇÑ', '„Å®„Åã'];
    const vagueCount = vagueWords.reduce((count, word) => 
      count + (text.includes(word) ? 1 : 0), 0);
    score -= vagueCount * 0.1;
    
    // ÂÖ∑‰ΩìÁöÑ„Å™Ë°®Áèæ„ÅÆÂä†ÁÇπ
    const concreteWords = ['ÂÆüÁèæ', 'ÈÅîÊàê', 'Êèê‰æõ', 'ÂâµÈÄ†', 'ÊßãÁØâ'];
    const concreteCount = concreteWords.reduce((count, word) => 
      count + (text.includes(word) ? 1 : 0), 0);
    score += concreteCount * 0.1;
    
    return Math.max(0, Math.min(1, score));
  };

  // ÂÖ∑‰ΩìÊÄßË©ï‰æ°
  const assessSpecificity = (text: string, _words: string[]): number => {
    let score = 0.3; // „Éô„Éº„Çπ„Çπ„Ç≥„Ç¢
    
    // Êï∞ÂÄ§„ÅÆÂ≠òÂú®
    const hasNumbers = /\d/.test(text);
    if (hasNumbers) score += 0.2;
    
    // ÂÖ∑‰ΩìÁöÑ„Å™Ê•≠ÁïåÁî®Ë™û
    const industryTerms = ['ÂåªÁôÇ', 'Ë£ΩÈÄ†', 'ÈáëËûç', 'IT', '„Ç®„Éç„É´„ÇÆ„Éº', 'Âª∫Ë®≠', 'Â∞èÂ£≤', 'ÊïôËÇ≤'];
    const industryCount = industryTerms.reduce((count, term) => 
      count + (text.includes(term) ? 1 : 0), 0);
    score += industryCount * 0.1;
    
    // ÊäΩË±°ÁöÑ„Å™Ë™û„ÅÆÊ∏õÁÇπ
    const abstractWords = ['Á¥†Êô¥„Çâ„Åó„ÅÑ', 'ÊúÄÈ´ò', 'ÂÆåÁíß', 'ÁêÜÊÉ≥'];
    const abstractCount = abstractWords.reduce((count, word) => 
      count + (text.includes(word) ? 1 : 0), 0);
    score -= abstractCount * 0.1;
    
    return Math.max(0, Math.min(1, score));
  };

  // Ë°åÂãïÊåáÂêëÊÄßË©ï‰æ°
  const assessActionability = (text: string, _words: string[], _type: string): number => {
    let score = 0.4; // „Éô„Éº„Çπ„Çπ„Ç≥„Ç¢
    
    // „Ç¢„ÇØ„Ç∑„Éß„É≥ÂãïË©û
    const actionVerbs = ['„Åô„Çã', 'Ë°å„ÅÜ', 'ÂÆüÊñΩ', 'Êé®ÈÄ≤', 'Â±ïÈñã', 'Ââµ„Çã', 'ÁØâ„Åè', 'Êèê‰æõ', 'ÊîØÊè¥'];
    const actionCount = actionVerbs.reduce((count, verb) => 
      count + (text.includes(verb) ? 1 : 0), 0);
    score += actionCount * 0.1;
    
    // ÁõÆÊ®ôË®≠ÂÆö„ÅÆË°®Áèæ
    const goalWords = ['ÁõÆÊåá„Åô', 'ÂÆüÁèæ', 'ÈÅîÊàê', 'Ë≤¢ÁåÆ', 'Âêë‰∏ä'];
    const goalCount = goalWords.reduce((count, word) => 
      count + (text.includes(word) ? 1 : 0), 0);
    score += goalCount * 0.1;
    
    return Math.max(0, Math.min(1, score));
  };

  // Áã¨Ëá™ÊÄßË©ï‰æ°
  const assessAuthenticity = (words: string[]): number => {
    let score = 0.5; // „Éô„Éº„Çπ„Çπ„Ç≥„Ç¢
    
    // ‰∏ÄËà¨ÁöÑ„Åô„Åé„ÇãË™û„ÅÆÊ∏õÁÇπ
    const commonWords = ['‰ºöÁ§æ', '‰ºÅÊ•≠', '‰∫ãÊ•≠', 'È°ßÂÆ¢', 'Á§æ‰ºö', '„Çµ„Éº„Éì„Çπ'];
    const commonCount = commonWords.reduce((count, word) => 
      count + (words.includes(word) ? 1 : 0), 0);
    score -= commonCount * 0.05;
    
    // „É¶„Éã„Éº„ÇØ„Å™Ë™ûÂΩô„ÅÆÂä†ÁÇπ
    const uniqueWords = ['Èù©Êñ∞', '„Ç§„Éé„Éô„Éº„Ç∑„Éß„É≥', 'Â§âÈù©', 'ÂÖàÈßÜ', '„Éë„Ç§„Ç™„Éã„Ç¢'];
    const uniqueCount = uniqueWords.reduce((count, word) => 
      count + (words.includes(word) ? 1 : 0), 0);
    score += uniqueCount * 0.1;
    
    return Math.max(0, Math.min(1, score));
  };

  // ÂÆåÂÖ®ÊÄßË©ï‰æ°
  const calculateCompleteness = (mission?: string, vision?: string, values?: string): number => {
    let score = 0;
    if (mission && mission.trim().length > 10) score += 0.33;
    if (vision && vision.trim().length > 10) score += 0.33;
    if (values && values.trim().length > 10) score += 0.34;
    return score;
  };

  // Êé®Â•®‰∫ãÈ†ÖÁîüÊàê
  const generateRecommendations = (_company: any, metrics: QualityMetrics): string[] => {
    const recommendations: string[] = [];
    
    if (metrics.clarity < 0.6) {
      recommendations.push('„Çà„ÇäÊòéÁ¢∫„ÅßÁêÜËß£„Åó„ÇÑ„Åô„ÅÑË°®Áèæ„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„ÇíÊé®Â•®„Åó„Åæ„Åô');
    }
    if (metrics.specificity < 0.6) {
      recommendations.push('ÂÖ∑‰ΩìÁöÑ„Å™Êï∞ÂÄ§„ÇÑÊ•≠ÁïåÂõ∫Êúâ„ÅÆÁî®Ë™û„ÇíÂê´„ÇÅ„Çã„Åì„Å®„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
    }
    if (metrics.actionability < 0.6) {
      recommendations.push('Ë°åÂãï„Çí‰øÉ„Åô„Çà„ÅÜ„Å™„Ç¢„ÇØ„Ç∑„Éß„É≥ÂãïË©û„ÅÆ‰ΩøÁî®„ÇíÊé®Â•®„Åó„Åæ„Åô');
    }
    if (metrics.authenticity < 0.6) {
      recommendations.push('‰ºÅÊ•≠Áã¨Ëá™„ÅÆ‰æ°ÂÄ§„ÇÑÁâπÂæ¥„Çí„Çà„ÇäÂº∑Ë™ø„Åô„Çã„Åì„Å®„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
    }
    if (metrics.completeness < 0.8) {
      recommendations.push('„Éü„ÉÉ„Ç∑„Éß„É≥„ÄÅ„Éì„Ç∏„Éß„É≥„ÄÅ„Éê„É™„É•„Éº„ÅÆ„Åô„Åπ„Å¶„ÇíÂÖÖÂÆü„Åï„Åõ„Çã„Åì„Å®„ÇíÊé®Â•®„Åó„Åæ„Åô');
    }
    
    return recommendations;
  };

  // „Ç∞„É¨„Éº„ÉâÁÆóÂá∫
  const calculateGrade = (score: number): 'A' | 'B' | 'C' | 'D' | 'F' => {
    if (score >= 0.9) return 'A';
    if (score >= 0.8) return 'B';
    if (score >= 0.7) return 'C';
    if (score >= 0.6) return 'D';
    return 'F';
  };

  const { assessments, categoryStats, loading } = useMemo(() => {
    if (!data || !data.companies) {
      return { assessments: [], categoryStats: {}, loading: true };
    }

    console.log('üîÑ MVVÂìÅË≥™Ë©ï‰æ°ÂàÜÊûêÈñãÂßã...');
    const startTime = performance.now();

    // ÊúâÂäπ„Å™‰ºÅÊ•≠„ÅÆ„Åø„Éï„Ç£„É´„Çø„Éº
    const validCompanies = data.companies.filter(company => 
      company.mission || company.vision || company.values
    );

    if (validCompanies.length === 0) {
      return { assessments: [], categoryStats: {}, loading: false };
    }

    console.log(`üìä ${validCompanies.length}Á§æ„ÅßÂìÅË≥™Ë©ï‰æ°ÂÆüË°å‰∏≠...`);

    const assessments: CompanyAssessment[] = validCompanies.map(company => {
      const missionMetrics = assessMVVText(company.mission || '', 'mission', segmenter);
      const visionMetrics = assessMVVText(company.vision || '', 'vision', segmenter);
      const valuesMetrics = assessMVVText(company.values || '', 'values', segmenter);

      // Á∑èÂêàË©ï‰æ°
      const overall: QualityMetrics = {
        clarity: (missionMetrics.clarity + visionMetrics.clarity + valuesMetrics.clarity) / 3,
        specificity: (missionMetrics.specificity + visionMetrics.specificity + valuesMetrics.specificity) / 3,
        actionability: (missionMetrics.actionability + visionMetrics.actionability + valuesMetrics.actionability) / 3,
        authenticity: (missionMetrics.authenticity + visionMetrics.authenticity + valuesMetrics.authenticity) / 3,
        completeness: calculateCompleteness(company.mission, company.vision, company.values),
        overall: 0
      };
      overall.overall = (overall.clarity + overall.specificity + overall.actionability + overall.authenticity + overall.completeness) / 5;

      // Êé®Â•®‰∫ãÈ†Ö
      const recommendations = generateRecommendations(company, overall);

      // „Ç∞„É¨„Éº„ÉâÁÆóÂá∫
      const grade = calculateGrade(overall.overall);

      return {
        companyId: company.id,
        companyName: company.name,
        category: company.category,
        mission: missionMetrics,
        vision: visionMetrics,
        values: valuesMetrics,
        overall,
        recommendations,
        grade
      };
    });

    // „Ç´„ÉÜ„Ç¥„É™Âà•Áµ±Ë®à
    const categoryStats = assessments.reduce((acc, assessment) => {
      const category = assessment.category;
      if (!acc[category]) {
        acc[category] = {
          count: 0,
          avgOverall: 0,
          gradeDistribution: { A: 0, B: 0, C: 0, D: 0, F: 0 },
          topIssues: []
        };
      }
      acc[category].count++;
      acc[category].avgOverall += assessment.overall.overall;
      acc[category].gradeDistribution[assessment.grade]++;
      return acc;
    }, {} as any);

    // Âπ≥Âùá„Çπ„Ç≥„Ç¢Ë®àÁÆó
    Object.keys(categoryStats).forEach(category => {
      categoryStats[category].avgOverall /= categoryStats[category].count;
    });

    const endTime = performance.now();
    console.log(`‚úÖ MVVÂìÅË≥™Ë©ï‰æ°ÂÆå‰∫Ü: ${Math.round(endTime - startTime)}ms`);

    return { assessments, categoryStats, loading: false };
  }, [data, segmenter]);

  const filteredAssessments = useMemo(() => {
    let filtered = assessments;
    
    if (selectedCategory !== 'all') {
      filtered = filtered.filter(assessment => assessment.category === selectedCategory);
    }
    
    return filtered.sort((a, b) => {
      const aScore = sortBy === 'overall' ? a.overall.overall : a[sortBy].overall;
      const bScore = sortBy === 'overall' ? b.overall.overall : b[sortBy].overall;
      return bScore - aScore;
    });
  }, [assessments, selectedCategory, sortBy]);

  const categories = useMemo(() => {
    return ['all', ...Object.keys(categoryStats)];
  }, [categoryStats]);

  if (isLoading || loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <LoadingSpinner size="lg" className="mb-4" />
          <p className="text-gray-600">MVVÂìÅË≥™„ÇíË©ï‰æ°‰∏≠...</p>
        </div>
      </div>
    );
  }

  const getGradeColor = (grade: string) => {
    switch (grade) {
      case 'A': return 'text-green-600 bg-green-100';
      case 'B': return 'text-blue-600 bg-blue-100';
      case 'C': return 'text-yellow-600 bg-yellow-100';
      case 'D': return 'text-orange-600 bg-orange-100';
      case 'F': return 'text-red-600 bg-red-100';
      default: return 'text-gray-600 bg-gray-100';
    }
  };

  const getScoreIcon = (score: number) => {
    if (score >= 0.8) return <CheckCircle className="w-4 h-4 text-green-500" />;
    if (score >= 0.6) return <AlertTriangle className="w-4 h-4 text-yellow-500" />;
    return <XCircle className="w-4 h-4 text-red-500" />;
  };

  return (
    <div className="space-y-6">
      {/* „Éò„ÉÉ„ÉÄ„Éº */}
      <div className="bg-white rounded-lg shadow-sm border p-6">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-2xl font-bold text-gray-900 flex items-center">
              <Award className="mr-3 h-8 w-8 text-indigo-500" />
              MVVÂìÅË≥™Ë©ï‰æ°„Ç∑„Çπ„ÉÜ„É†
            </h2>
            <p className="text-gray-600 mt-1">
              „É´„Éº„É´„Éô„Éº„ÇπÂàÜÊûê„Å´„Çà„ÇãÂåÖÊã¨ÁöÑ„Å™MVVÂìÅË≥™Ë©ï‰æ°
            </p>
          </div>
          <div className="text-sm text-gray-500">
            Ë©ï‰æ°ÂØæË±°: {assessments.length}Á§æ
          </div>
        </div>
      </div>

      {/* „Éï„Ç£„É´„Çø„Éº */}
      <div className="bg-white rounded-lg shadow-sm border p-4">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">„Ç´„ÉÜ„Ç¥„É™:</label>
            <select
              value={selectedCategory}
              onChange={(e) => setSelectedCategory(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
            >
              {categories.map(category => (
                <option key={category} value={category}>
                  {category === 'all' ? '„Åô„Åπ„Å¶' : category}
                </option>
              ))}
            </select>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">‰∏¶„Å≥È†Ü:</label>
            <select
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value as any)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
            >
              <option value="overall">Á∑èÂêà„Çπ„Ç≥„Ç¢</option>
              <option value="mission">„Éü„ÉÉ„Ç∑„Éß„É≥</option>
              <option value="vision">„Éì„Ç∏„Éß„É≥</option>
              <option value="values">„Éê„É™„É•„Éº</option>
            </select>
          </div>
          
          <div className="flex items-end">
            <div className="text-sm text-gray-600">
              ÁµêÊûú: {filteredAssessments.length}Á§æ
            </div>
          </div>
        </div>
      </div>

      {/* ÂìÅË≥™Ë©ï‰æ°ÁµêÊûú */}
      <div className="space-y-4">
        {filteredAssessments.map(assessment => (
          <div key={assessment.companyId} className="bg-white rounded-lg shadow-sm border p-6">
            <div className="flex items-start justify-between mb-4">
              <div>
                <div className="flex items-center space-x-3">
                  <h3 className="text-lg font-semibold text-gray-900">{assessment.companyName}</h3>
                  <span className={`px-2 py-1 rounded-full text-sm font-bold ${getGradeColor(assessment.grade)}`}>
                    {assessment.grade}
                  </span>
                </div>
                <p className="text-sm text-gray-600">{assessment.category}</p>
              </div>
              <div className="text-right">
                <div className="text-2xl font-bold text-gray-900">
                  {Math.round(assessment.overall.overall * 100)}
                </div>
                <div className="text-xs text-gray-500">Á∑èÂêà„Çπ„Ç≥„Ç¢</div>
              </div>
            </div>

            {/* Ë©≥Á¥∞„Çπ„Ç≥„Ç¢ */}
            <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-4">
              <div className="text-center p-3 bg-gray-50 rounded">
                <div className="flex items-center justify-center mb-1">
                  {getScoreIcon(assessment.overall.clarity)}
                </div>
                <div className="text-sm font-medium">{Math.round(assessment.overall.clarity * 100)}</div>
                <div className="text-xs text-gray-600">ÊòéÁ¢∫ÊÄß</div>
              </div>
              <div className="text-center p-3 bg-gray-50 rounded">
                <div className="flex items-center justify-center mb-1">
                  {getScoreIcon(assessment.overall.specificity)}
                </div>
                <div className="text-sm font-medium">{Math.round(assessment.overall.specificity * 100)}</div>
                <div className="text-xs text-gray-600">ÂÖ∑‰ΩìÊÄß</div>
              </div>
              <div className="text-center p-3 bg-gray-50 rounded">
                <div className="flex items-center justify-center mb-1">
                  {getScoreIcon(assessment.overall.actionability)}
                </div>
                <div className="text-sm font-medium">{Math.round(assessment.overall.actionability * 100)}</div>
                <div className="text-xs text-gray-600">Ë°åÂãïÊÄß</div>
              </div>
              <div className="text-center p-3 bg-gray-50 rounded">
                <div className="flex items-center justify-center mb-1">
                  {getScoreIcon(assessment.overall.authenticity)}
                </div>
                <div className="text-sm font-medium">{Math.round(assessment.overall.authenticity * 100)}</div>
                <div className="text-xs text-gray-600">Áã¨Ëá™ÊÄß</div>
              </div>
              <div className="text-center p-3 bg-gray-50 rounded">
                <div className="flex items-center justify-center mb-1">
                  {getScoreIcon(assessment.overall.completeness)}
                </div>
                <div className="text-sm font-medium">{Math.round(assessment.overall.completeness * 100)}</div>
                <div className="text-xs text-gray-600">ÂÆåÂÖ®ÊÄß</div>
              </div>
            </div>

            {/* Êé®Â•®‰∫ãÈ†Ö */}
            {assessment.recommendations.length > 0 && (
              <div className="border-t pt-4">
                <h4 className="text-sm font-medium text-gray-900 mb-2">ÊîπÂñÑÊé®Â•®‰∫ãÈ†Ö:</h4>
                <ul className="text-sm text-gray-600 space-y-1">
                  {assessment.recommendations.map((rec, index) => (
                    <li key={index}>‚Ä¢ {rec}</li>
                  ))}
                </ul>
              </div>
            )}
          </div>
        ))}
      </div>

      {/* „Ç´„ÉÜ„Ç¥„É™Âà•Áµ±Ë®à */}
      <div className="bg-white rounded-lg shadow-sm border p-6">
        <h3 className="text-lg font-semibold text-gray-900 mb-4 flex items-center">
          <BarChart3 className="mr-2 h-5 w-5 text-indigo-500" />
          „Ç´„ÉÜ„Ç¥„É™Âà•ÂìÅË≥™Áµ±Ë®à
        </h3>
        
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {Object.entries(categoryStats).map(([category, stats]: [string, any]) => (
            <div key={category} className="border rounded-lg p-4">
              <div className="font-semibold text-gray-900 mb-3">{category}</div>
              
              <div className="space-y-2 text-sm">
                <div className="flex justify-between">
                  <span className="text-gray-600">‰ºÅÊ•≠Êï∞:</span>
                  <span className="font-medium">{stats.count}Á§æ</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-600">Âπ≥Âùá„Çπ„Ç≥„Ç¢:</span>
                  <span className="font-medium">{Math.round(stats.avgOverall * 100)}</span>
                </div>
                <div className="mt-3">
                  <div className="text-gray-600 mb-1">„Ç∞„É¨„Éº„ÉâÂàÜÂ∏É:</div>
                  <div className="flex space-x-1">
                    {Object.entries(stats.gradeDistribution).map(([grade, count]: [string, any]) => (
                      <div key={grade} className={`px-2 py-1 rounded text-xs ${getGradeColor(grade)}`}>
                        {grade}: {count}
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};